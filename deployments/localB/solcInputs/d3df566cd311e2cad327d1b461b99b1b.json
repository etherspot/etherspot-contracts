{
  "language": "Solidity",
  "sources": {
    "src/account/AccountOwnerRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../common/libs/BlockLib.sol\";\n\n\n/**\n * @title AccountOwnerRegistry\n */\ncontract AccountOwnerRegistry {\n  using BlockLib for BlockLib.BlockRelated;\n\n  mapping(address => mapping(address => BlockLib.BlockRelated)) private accountOwners;\n\n  // events\n\n  event AccountOwnerAdded(\n    address account,\n    address owner\n  );\n\n  event AccountOwnerRemoved(\n    address account,\n    address owner\n  );\n\n  // external functions\n\n  function addAccountOwner(\n    address owner\n  )\n    external\n  {\n    require(\n      !accountOwners[msg.sender][owner].verifyAtCurrentBlock()\n    );\n\n    accountOwners[msg.sender][owner].added = true;\n    accountOwners[msg.sender][owner].removedAtBlockNumber = 0;\n\n    emit AccountOwnerAdded(\n      msg.sender,\n      owner\n    );\n  }\n\n  function removeAccountOwner(\n    address owner\n  )\n    external\n  {\n    require(\n      accountOwners[msg.sender][owner].verifyAtCurrentBlock()\n    );\n\n    accountOwners[msg.sender][owner].removedAtBlockNumber = block.number;\n\n    emit AccountOwnerRemoved(\n      msg.sender,\n      owner\n    );\n  }\n\n  // external functions (views)\n\n  function verifyAccountOwner(\n    address account,\n    address owner\n  )\n    external\n    view\n    returns (bool)\n  {\n    return accountOwners[account][owner].verifyAtCurrentBlock();\n  }\n\n  function verifyAccountOwnerAtBlock(\n    address account,\n    address owner,\n    uint256 blockNumber\n  )\n    external\n    view\n    returns (bool)\n  {\n    return accountOwners[account][owner].verifyAtBlock(blockNumber);\n  }\n}\n"
    },
    "src/common/libs/BlockLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @title BlockLib\n */\nlibrary BlockLib {\n  struct BlockRelated {\n    bool added;\n    uint256 removedAtBlockNumber;\n  }\n\n  function verifyAtCurrentBlock(\n    BlockRelated memory self\n  )\n    internal\n    view\n    returns (bool)\n  {\n    return verifyAtBlock(self, block.number);\n  }\n\n  function verifyAtAnyBlock(\n    BlockRelated memory self\n  )\n    internal\n    pure\n    returns (bool)\n  {\n    return verifyAtBlock(self, 0);\n  }\n\n  function verifyAtBlock(\n    BlockRelated memory self,\n    uint256 blockNumber\n  )\n    internal\n    pure\n    returns (bool)\n  {\n    bool result = false;\n\n    if (self.added) {\n      if (self.removedAtBlockNumber == 0) {\n        result = true;\n      } else if (blockNumber == 0) {\n        result = true;\n      } else {\n        result = self.removedAtBlockNumber > blockNumber;\n      }\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/payment/PaymentRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../account/AccountOwnerRegistry.sol\";\nimport \"../account/AccountProofRegistry.sol\";\nimport \"../common/access/Guarded.sol\";\nimport \"../common/account/AccountController.sol\";\nimport \"../common/libs/SafeMathLib.sol\";\nimport \"../common/libs/SignatureLib.sol\";\nimport \"../common/lifecycle/Initializable.sol\";\nimport \"../common/token/ERC20Token.sol\";\nimport \"../common/typedData/TypedDataContainer.sol\";\nimport \"../personal/PersonalAccountRegistry.sol\";\nimport \"../gateway/GatewayRecipient.sol\";\n\n\n/**\n * @title PaymentRegistry\n */\ncontract PaymentRegistry is Guarded, AccountController, Initializable, TypedDataContainer, GatewayRecipient {\n  using SafeMathLib for uint256;\n  using SignatureLib for bytes32;\n\n  struct Deposit {\n    address account;\n    mapping(address => uint256) withdrawalLockedUntil;\n  }\n\n  struct PaymentChannel {\n    uint256 committedAmount;\n  }\n\n  struct PaymentChannelCommit {\n    address sender;\n    address recipient;\n    address token;\n    bytes32 uid;\n    uint256 blockNumber;\n    uint256 amount;\n  }\n\n  bytes32 private constant PAYMENT_CHANNEL_COMMIT_TYPE_HASH = keccak256(\n    \"PaymentChannelCommit(address sender,address recipient,address token,bytes32 uid,uint256 blockNumber,uint256 amount)\"\n  );\n  uint256 private constant DEFAULT_DEPOSIT_WITHDRAWAL_LOCK_PERIOD = 30 days;\n\n  AccountOwnerRegistry public accountOwnerRegistry;\n  AccountProofRegistry public accountProofRegistry;\n  PersonalAccountRegistry public personalAccountRegistry;\n  uint256 public depositWithdrawalLockPeriod;\n  mapping(address => Deposit) private deposits;\n  mapping(bytes32 => PaymentChannel) private paymentChannels;\n\n  // events\n\n  event DepositAccountDeployed(\n    address depositAccount,\n    address owner\n  );\n\n  event DepositWithdrawalRequested(\n    address depositAccount,\n    address owner,\n    address token,\n    uint256 lockedUntil\n  );\n\n  event DepositWithdrawalRejected(\n    address depositAccount,\n    address owner,\n    address token\n  );\n\n  event DepositWithdrawn(\n    address depositAccount,\n    address owner,\n    address token,\n    uint256 amount\n  );\n\n  event PaymentChannelCommitted(\n    bytes32 hash,\n    address sender,\n    address recipient,\n    address token,\n    bytes32 uid,\n    uint256 amount\n  );\n\n  event PaymentWithdrawn(\n    bytes32 channelHash,\n    uint256 value\n  );\n\n  event PaymentDeposited(\n    bytes32 channelHash,\n    uint256 value\n  );\n\n  event PaymentSplit(\n    bytes32 channelHash,\n    uint256 totalValue,\n    uint256 depositValue\n  );\n\n  /**\n   * @dev public constructor\n   */\n  constructor() public Guarded() Initializable() {}\n\n  // external functions\n\n  function initialize(\n    AccountOwnerRegistry accountOwnerRegistry_,\n    AccountProofRegistry accountProofRegistry_,\n    PersonalAccountRegistry personalAccountRegistry_,\n    uint256 depositWithdrawalLockPeriod_,\n    address[] calldata guardians_,\n    address gateway_,\n    bytes32 typedDataDomainNameHash,\n    bytes32 typedDataDomainVersionHash,\n    bytes32 typedDataDomainSalt\n  )\n    external\n    onlyInitializer\n  {\n    accountOwnerRegistry = accountOwnerRegistry_;\n    accountProofRegistry = accountProofRegistry_;\n    personalAccountRegistry = personalAccountRegistry_;\n\n    if (depositWithdrawalLockPeriod_ == 0) {\n      depositWithdrawalLockPeriod = DEFAULT_DEPOSIT_WITHDRAWAL_LOCK_PERIOD;\n    } else {\n      depositWithdrawalLockPeriod = depositWithdrawalLockPeriod_;\n    }\n\n    // Guarded\n    _initializeGuarded(guardians_);\n\n    // GatewayRecipient\n    _initializeGatewayRecipient(gateway_);\n\n    // TypedDataContainer\n    _initializeTypedDataContainer(\n      typedDataDomainNameHash,\n      typedDataDomainVersionHash,\n      typedDataDomainSalt\n    );\n  }\n\n  function deployDepositAccount(\n    address owner\n  )\n    external\n  {\n    _deployDepositAccount(owner);\n  }\n\n  function withdrawDeposit(\n    address token\n  )\n    external\n  {\n    address owner = _getContextAccount();\n    uint256 lockedUntil = deposits[owner].withdrawalLockedUntil[token];\n\n    /* solhint-disable not-rely-on-time */\n\n    if (lockedUntil != 0 && lockedUntil <= now) {\n      deposits[owner].withdrawalLockedUntil[token] = 0;\n\n      address depositAccount = deposits[owner].account;\n      uint256 depositValue;\n\n      if (token == address(0)) {\n        depositValue = depositAccount.balance;\n      } else {\n        depositValue = ERC20Token(token).balanceOf(depositAccount);\n      }\n\n      _transferFromDeposit(\n        depositAccount,\n        owner,\n        token,\n        depositValue\n      );\n\n      emit DepositWithdrawn(\n        depositAccount,\n        owner,\n        token,\n        depositValue\n      );\n    } else {\n      _deployDepositAccount(owner);\n\n      lockedUntil = now.add(depositWithdrawalLockPeriod);\n\n      deposits[owner].withdrawalLockedUntil[token] = lockedUntil;\n\n      emit DepositWithdrawalRequested(\n        deposits[owner].account,\n        owner,\n        token,\n        lockedUntil\n      );\n    }\n    /* solhint-enable not-rely-on-time */\n  }\n\n  function commitPaymentChannelAndWithdraw(\n    address sender,\n    address token,\n    bytes32 uid,\n    uint256 blockNumber,\n    uint256 amount,\n    bytes calldata senderSignature,\n    bytes calldata guardianSignature\n  )\n    external\n  {\n    address recipient = _getContextAccount();\n\n    (bytes32 hash, address depositAccount, uint256 paymentValue) = _commitPaymentChannel(\n      sender,\n      recipient,\n      token,\n      uid,\n      blockNumber,\n      amount,\n      senderSignature,\n      guardianSignature\n    );\n\n    _transferFromDeposit(\n      depositAccount,\n      recipient,\n      token,\n      paymentValue\n    );\n\n    emit PaymentWithdrawn(hash, paymentValue);\n  }\n\n  function commitPaymentChannelAndDeposit(\n    address sender,\n    address token,\n    bytes32 uid,\n    uint256 blockNumber,\n    uint256 amount,\n    bytes calldata senderSignature,\n    bytes calldata guardianSignature\n  )\n    external\n  {\n    address recipient = _getContextAccount();\n\n    (bytes32 hash, address depositAccount, uint256 paymentValue) = _commitPaymentChannel(\n      sender,\n      recipient,\n      token,\n      uid,\n      blockNumber,\n      amount,\n      senderSignature,\n      guardianSignature\n    );\n\n    _transferFromDeposit(\n      depositAccount,\n      _computeDepositAccountAddress(recipient),\n      token,\n      paymentValue\n    );\n\n    emit PaymentDeposited(hash, paymentValue);\n  }\n\n  function commitPaymentChannelAndSplit(\n    address sender,\n    address token,\n    bytes32 uid,\n    uint256 blockNumber,\n    uint256 amount,\n    uint256 depositPaymentValue,\n    bytes calldata senderSignature,\n    bytes calldata guardianSignature\n  )\n    external\n  {\n    address recipient = _getContextAccount();\n\n    (bytes32 hash, address depositAccount, uint256 paymentValue) = _commitPaymentChannel(\n      sender,\n      recipient,\n      token,\n      uid,\n      blockNumber,\n      amount,\n      senderSignature,\n      guardianSignature\n    );\n\n    _transferSplitFromDeposit(\n      depositAccount,\n      recipient,\n      token,\n      paymentValue,\n      depositPaymentValue\n    );\n\n    emit PaymentSplit(hash, paymentValue, depositPaymentValue);\n  }\n\n  // external functions (views)\n\n  function computeDepositAccountAddress(\n    address owner\n  )\n    external\n    view\n    returns (address)\n  {\n    return _computeDepositAccountAddress(owner);\n  }\n\n  function isDepositAccountDeployed(\n    address owner\n  )\n    external\n    view\n    returns (bool)\n  {\n    return deposits[owner].account != address(0);\n  }\n\n  function getDepositWithdrawalLockedUntil(\n    address owner,\n    address token\n  )\n    external\n    view\n    returns (uint256)\n  {\n    return deposits[owner].withdrawalLockedUntil[token];\n  }\n\n  function getPaymentChannelCommittedAmount(\n    bytes32 hash\n  )\n    external\n    view\n    returns (uint256)\n  {\n    return paymentChannels[hash].committedAmount;\n  }\n\n  // external functions (pure)\n\n  function computePaymentChannelHash(\n    address sender,\n    address recipient,\n    address token,\n    bytes32 uid\n  )\n    external\n    pure\n    returns (bytes32)\n  {\n    return _computePaymentChannelHash(\n      sender,\n      recipient,\n      token,\n      uid\n    );\n  }\n\n  // public functions (views)\n\n  function hashPaymentChannelCommit(\n    PaymentChannelCommit memory paymentChannelCommit\n  )\n    public\n    view\n    returns (bytes32)\n  {\n    return _hashPrimaryTypedData(\n      _hashTypedData(\n        paymentChannelCommit.sender,\n        paymentChannelCommit.recipient,\n        paymentChannelCommit.token,\n        paymentChannelCommit.uid,\n        paymentChannelCommit.blockNumber,\n        paymentChannelCommit.amount\n      )\n    );\n  }\n\n  // private functions\n\n  function _deployDepositAccount(\n    address owner\n  )\n    private\n  {\n    if (deposits[owner].account == address(0)) {\n      bytes32 salt = keccak256(\n        abi.encodePacked(\n          owner\n        )\n      );\n\n      deposits[owner].account = _deployAccount(salt);\n\n      emit DepositAccountDeployed(deposits[owner].account, owner);\n    }\n  }\n\n  function _commitPaymentChannel(\n    address sender,\n    address recipient,\n    address token,\n    bytes32 uid,\n    uint256 blockNumber,\n    uint256 amount,\n    bytes memory senderSignature,\n    bytes memory guardianSignature\n  )\n    private\n    returns (bytes32 hash, address depositAccount, uint256 paymentValue)\n  {\n    bytes32 messageHash = _hashPrimaryTypedData(\n      _hashTypedData(\n        sender,\n        recipient,\n        token,\n        uid,\n        blockNumber,\n        amount\n      )\n    );\n\n    if (senderSignature.length == 0) {\n      require(\n        accountProofRegistry.verifyAccountProofAtBlock(sender, messageHash, blockNumber)\n      );\n    } else {\n      address signer = messageHash.recoverAddress(senderSignature);\n\n      if (sender != signer) {\n        require(\n          personalAccountRegistry.verifyAccountOwnerAtBlock(sender, signer, blockNumber) ||\n          accountOwnerRegistry.verifyAccountOwnerAtBlock(sender, signer, blockNumber)\n        );\n      }\n    }\n\n    require(\n      _verifyGuardianSignature(messageHash, guardianSignature)\n    );\n\n    hash = _computePaymentChannelHash(\n      sender,\n      recipient,\n      token,\n      uid\n    );\n\n    // calc payment value\n    paymentValue = amount.sub(paymentChannels[hash].committedAmount);\n\n    require(\n      paymentValue != 0\n    );\n\n    paymentChannels[hash].committedAmount = amount;\n\n    if (deposits[sender].withdrawalLockedUntil[token] > 0) {\n      deposits[sender].withdrawalLockedUntil[token] = 0;\n\n      emit DepositWithdrawalRejected(\n        deposits[sender].account,\n        sender,\n        token\n      );\n    } else {\n      _deployDepositAccount(sender);\n    }\n\n    depositAccount = deposits[sender].account;\n\n    emit PaymentChannelCommitted(\n      hash,\n      sender,\n      recipient,\n      token,\n      uid,\n      amount\n    );\n\n    return (hash, depositAccount, paymentValue);\n  }\n\n  function _transferFromDeposit(\n    address depositAccount,\n    address to,\n    address token,\n    uint256 value\n  )\n    private\n  {\n    if (token == address(0)) {\n      _executeAccountTransaction(\n        depositAccount,\n        to,\n        value,\n        new bytes(0)\n      );\n    } else {\n      bytes memory response = _executeAccountTransaction(\n        depositAccount,\n        token,\n        0,\n        abi.encodeWithSelector(\n          ERC20Token(token).transfer.selector,\n          to,\n          value\n        )\n      );\n\n      if (response.length > 0) {\n        require(\n          abi.decode(response, (bool))\n        );\n      }\n    }\n  }\n\n  function _transferSplitFromDeposit(\n    address depositAccount,\n    address to,\n    address token,\n    uint256 paymentValue,\n    uint256 depositValue\n  )\n    private\n  {\n    require(\n      depositValue > 0\n    );\n\n    uint256 withdrawValue = paymentValue.sub(depositValue);\n\n    require(\n      withdrawValue > 0\n    );\n\n    _transferFromDeposit(\n      depositAccount,\n      to,\n      token,\n      withdrawValue\n    );\n\n    _transferFromDeposit(\n      depositAccount,\n      _computeDepositAccountAddress(to),\n      token,\n      depositValue\n    );\n  }\n\n  // private functions (views)\n\n  function _computeDepositAccountAddress(\n    address owner\n  )\n    private\n    view\n    returns (address)\n  {\n    bytes32 salt = keccak256(\n      abi.encodePacked(\n        owner\n      )\n    );\n\n    return _computeAccountAddress(salt);\n  }\n\n  // private functions (pure)\n\n  function _computePaymentChannelHash(\n    address sender,\n    address recipient,\n    address token,\n    bytes32 uid\n  )\n    private\n    pure\n    returns (bytes32)\n  {\n    return keccak256(\n      abi.encodePacked(\n        sender,\n        recipient,\n        token,\n        uid\n      )\n    );\n  }\n\n  function _hashTypedData(\n    address sender,\n    address recipient,\n    address token,\n    bytes32 uid,\n    uint256 blockNumber,\n    uint256 amount\n  )\n    private\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encode(\n      PAYMENT_CHANNEL_COMMIT_TYPE_HASH,\n      sender,\n      recipient,\n      token,\n      uid,\n      blockNumber,\n      amount\n    ));\n  }\n}\n"
    },
    "src/account/AccountProofRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../common/libs/BlockLib.sol\";\n\n\n/**\n * @title AccountProofRegistry\n */\ncontract AccountProofRegistry {\n  using BlockLib for BlockLib.BlockRelated;\n\n  mapping(address => mapping(bytes32 => BlockLib.BlockRelated)) private accountProofs;\n\n  // events\n\n  event AccountProofAdded(\n    address account,\n    bytes32 hash\n  );\n\n  event AccountProofRemoved(\n    address account,\n    bytes32 hash\n  );\n\n  // external functions\n\n  function addAccountProof(\n    bytes32 hash\n  )\n    external\n  {\n    require(\n      !accountProofs[msg.sender][hash].verifyAtCurrentBlock()\n    );\n\n    accountProofs[msg.sender][hash].added = true;\n    accountProofs[msg.sender][hash].removedAtBlockNumber = 0;\n\n    emit AccountProofAdded(\n      msg.sender,\n      hash\n    );\n  }\n\n  function removeAccountProof(\n    bytes32 hash\n  )\n    external\n  {\n    require(\n      accountProofs[msg.sender][hash].verifyAtCurrentBlock()\n    );\n\n    accountProofs[msg.sender][hash].removedAtBlockNumber = block.number;\n\n    emit AccountProofRemoved(\n      msg.sender,\n      hash\n    );\n  }\n\n  // external functions (views)\n\n  function verifyAccountProof(\n    address account,\n    bytes32 hash\n  )\n    external\n    view\n    returns (bool)\n  {\n    return accountProofs[account][hash].verifyAtCurrentBlock();\n  }\n\n  function verifyAccountProofAtBlock(\n    address account,\n    bytes32 hash,\n    uint256 blockNumber\n  )\n    external\n    view\n    returns (bool)\n  {\n    return accountProofs[account][hash].verifyAtBlock(blockNumber);\n  }\n}\n"
    },
    "src/common/access/Guarded.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../libs/SignatureLib.sol\";\n\n\n/**\n * @title Guarded\n */\ncontract Guarded {\n  using SignatureLib for bytes32;\n\n  mapping(address => bool) private guardians;\n\n  // events\n\n  event GuardianAdded(\n    address guardian\n  );\n\n  event GuardianRemoved(\n    address guardian\n  );\n\n  // modifiers\n\n  modifier onlyGuardian() {\n    require(\n      guardians[msg.sender]\n    );\n\n    _;\n  }\n\n  // external functions\n\n  function addGuardian(\n    address guardian\n  )\n    external\n    onlyGuardian\n  {\n    _addGuardian(guardian);\n  }\n\n  function removeGuardian(\n    address guardian\n  )\n    external\n    onlyGuardian\n  {\n    require(\n      msg.sender != guardian\n    );\n\n    require(\n      guardians[guardian]\n    );\n\n    guardians[guardian] = false;\n\n    emit GuardianRemoved(\n      guardian\n    );\n  }\n\n  // external functions (views)\n\n  function isGuardian(\n    address guardian\n  )\n    external\n    view\n    returns (bool)\n  {\n    return guardians[guardian];\n  }\n\n  function verifyGuardianSignature(\n    bytes32 messageHash,\n    bytes calldata signature\n  )\n    external\n    view\n    returns (bool)\n  {\n    return _verifyGuardianSignature(\n      messageHash,\n      signature\n    );\n  }\n\n  // internal functions\n\n  function _initializeGuarded(\n    address[] memory guardians_\n  )\n    internal\n  {\n    if (guardians_.length == 0) {\n      guardians[msg.sender] = true;\n    } else {\n      uint guardiansLen = guardians_.length;\n      for (uint i = 0; i < guardiansLen; i++) {\n        _addGuardian(guardians_[i]);\n      }\n    }\n  }\n\n\n  // internal functions (views)\n\n  function _verifyGuardianSignature(\n    bytes32 messageHash,\n    bytes memory signature\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address guardian = messageHash.recoverAddress(signature);\n\n    return guardians[guardian];\n  }\n\n  // private functions\n\n  function _addGuardian(\n    address guardian\n  )\n    private\n  {\n    require(\n      guardian != address(0)\n    );\n\n    require(\n      !guardians[guardian]\n    );\n\n    guardians[guardian] = true;\n\n    emit GuardianAdded(guardian);\n  }\n}\n"
    },
    "src/common/account/AccountController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./Account.sol\";\n\n\n/**\n * @title AccountController\n */\ncontract AccountController {\n  /**\n   * @dev internal constructor\n   */\n  constructor() internal {}\n\n  // internal functions\n\n  function _deployAccount(\n    bytes32 salt\n  )\n    internal\n    returns (address)\n  {\n    return address(new Account{salt: salt}());\n  }\n\n  function _executeAccountTransaction(\n    address account,\n    address to,\n    uint256 value,\n    bytes memory data\n  )\n    internal\n    returns (bytes memory)\n  {\n    require(\n      to != address(0)\n    );\n\n    require(\n      to != address(this)\n    );\n\n    require(\n      to != account\n    );\n\n    return Account(payable(account)).executeTransaction(\n      to,\n      value,\n      data\n    );\n  }\n\n  // internal functions (views)\n\n  function _computeAccountAddress(\n    bytes32 salt\n  )\n    internal\n    view\n    returns (address)\n  {\n    bytes memory creationCode = type(Account).creationCode;\n\n    bytes32 data = keccak256(\n      abi.encodePacked(\n        bytes1(0xff),\n        address(this),\n        salt,\n        keccak256(creationCode)\n      )\n    );\n\n    return address(uint160(uint256(data)));\n  }\n}\n"
    },
    "src/common/libs/SafeMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @title SafeMathLib\n */\nlibrary SafeMathLib {\n  function add(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 result = a + b;\n\n    require(\n      result >= a\n    );\n\n    return result;\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(\n      b <= a\n    );\n\n    return a - b;\n  }\n\n  function mul(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 result = 0;\n\n    if (a != 0 && b != 0) {\n      result = a * b;\n\n      require(\n        result / a == b\n      );\n    }\n\n    return result;\n  }\n\n  function div(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(\n      b != 0\n    );\n\n    return a / b;\n  }\n\n  function mod(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(\n      b != 0\n    );\n\n    return a % b;\n  }\n}\n"
    },
    "src/common/libs/SignatureLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @title SignatureLib\n */\nlibrary SignatureLib {\n  function recoverAddress(\n    bytes32 messageHash,\n    bytes memory signature\n  )\n    internal\n    pure\n    returns (address)\n  {\n    address result = address(0);\n\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n\n      // solhint-disable-next-line no-inline-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n\n      if (v < 27) {\n        v += 27;\n      }\n\n      if (v == 27 || v == 28) {\n        result = ecrecover(messageHash, v, r, s);\n      }\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/common/lifecycle/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @title Initializable\n */\ncontract Initializable {\n  address private initializer;\n\n  // events\n\n  event Initialized();\n\n  // modifiers\n\n  modifier onlyInitializer() {\n    require(\n      msg.sender == initializer\n    );\n\n    initializer = address(0);\n\n    _;\n\n    emit Initialized();\n  }\n\n  /**\n   * @dev internal constructor\n   */\n  constructor()\n    internal\n  {\n    initializer = msg.sender;\n  }\n\n   // external functions (views)\n\n  function isInitialized()\n    external\n    view\n    returns (bool)\n  {\n    return initializer == address(0);\n  }\n}\n"
    },
    "src/common/token/ERC20Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../libs/SafeMathLib.sol\";\n\n\n/**\n * @title ERC20Token\n */\ncontract ERC20Token {\n  using SafeMathLib for uint256;\n\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n  uint256 public totalSupply;\n\n  mapping(address => uint256) internal balances;\n  mapping(address => mapping(address => uint256)) internal allowances;\n\n  // events\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n\n  /**\n   * @dev internal constructor\n   */\n  constructor() internal {}\n\n  // external functions\n\n  function transfer(\n    address to,\n    uint256 value\n  )\n    external\n    returns (bool)\n  {\n    _transfer(msg.sender, to, value);\n\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    virtual\n    external\n    returns (bool)\n  {\n    _transfer(from, to, value);\n    _approve(from, msg.sender, allowances[from][msg.sender].sub(value));\n\n    return true;\n  }\n\n  function approve(\n    address spender,\n    uint256 value\n  )\n    virtual\n    external\n    returns (bool)\n  {\n    _approve(msg.sender, spender, value);\n\n    return true;\n  }\n\n  // external functions (views)\n\n  function balanceOf(\n    address owner\n  )\n    virtual\n    external\n    view\n    returns (uint256)\n  {\n    return balances[owner];\n  }\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    virtual\n    external\n    view\n    returns (uint256)\n  {\n    return allowances[owner][spender];\n  }\n\n  // internal functions\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 value\n  )\n    virtual\n    internal\n  {\n    require(\n      from != address(0)\n    );\n    require(\n      to != address(0)\n    );\n\n    balances[from] = balances[from].sub(value);\n    balances[to] = balances[to].add(value);\n\n    emit Transfer(from, to, value);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 value\n  )\n    virtual\n    internal\n  {\n    require(\n      owner != address(0)\n    );\n    require(\n      spender != address(0)\n    );\n\n    allowances[owner][spender] = value;\n\n    emit Approval(owner, spender, value);\n  }\n\n  function _mint(\n    address owner,\n    uint256 value\n  )\n    virtual\n    internal\n  {\n    require(\n      owner != address(0)\n    );\n\n    require(\n      value > 0\n    );\n\n    balances[owner] = balances[owner].add(value);\n    totalSupply = totalSupply.add(value);\n\n    emit Transfer(address(0), owner, value);\n  }\n\n  function _burn(\n    address owner,\n    uint256 value\n  )\n    virtual\n    internal\n  {\n    require(\n      owner != address(0)\n    );\n\n    require(\n      value > 0\n    );\n\n    balances[owner] = balances[owner].sub(value);\n    totalSupply = totalSupply.sub(value);\n\n    emit Transfer(owner, address(0), value);\n  }\n}\n"
    },
    "src/common/typedData/TypedDataContainer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @title TypedDataContainer\n */\ncontract TypedDataContainer {\n  string private constant TYPED_DATA_PREFIX = \"\\x19\\x01\";\n  bytes32 private constant TYPED_DATA_DOMAIN_TYPE_HASH = keccak256(\n    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"\n  );\n\n  bytes32 public typedDataDomainSeparator;\n\n  /**\n   * @dev internal constructor\n   */\n  constructor() internal {}\n\n  // internal functions\n\n  function _initializeTypedDataContainer(\n    bytes32 domainNameHash,\n    bytes32 domainVersionHash,\n    bytes32 domainSalt\n  )\n    internal\n  {\n    uint256 chainId;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      chainId := chainid()\n    }\n\n    typedDataDomainSeparator = keccak256(abi.encode(\n        TYPED_DATA_DOMAIN_TYPE_HASH,\n        domainNameHash,\n        domainVersionHash,\n        chainId,\n        address(this),\n        domainSalt\n    ));\n  }\n\n  // internal functions (views)\n\n  function _hashPrimaryTypedData(\n    bytes32 dataHash\n  )\n    internal\n    view\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(\n      TYPED_DATA_PREFIX,\n      typedDataDomainSeparator,\n      dataHash\n    ));\n  }\n}\n"
    },
    "src/personal/PersonalAccountRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../common/account/AccountController.sol\";\nimport \"../common/libs/BlockLib.sol\";\nimport \"../common/libs/SafeMathLib.sol\";\nimport \"../common/lifecycle/Initializable.sol\";\nimport \"../common/token/ERC20Token.sol\";\nimport \"../gateway/GatewayRecipient.sol\";\n\n\n/**\n * @title PersonalAccountRegistry\n */\ncontract PersonalAccountRegistry is AccountController, Initializable, GatewayRecipient {\n  using BlockLib for BlockLib.BlockRelated;\n  using SafeMathLib for uint256;\n\n  struct Account {\n    bool deployed;\n    bytes32 salt;\n    mapping(address => BlockLib.BlockRelated) owners;\n  }\n\n  mapping(address => Account) private accounts;\n\n  // events\n\n  event AccountDeployed(\n    address account\n  );\n\n  event AccountOwnerAdded(\n    address account,\n    address owner\n  );\n\n  event AccountOwnerRemoved(\n    address account,\n    address owner\n  );\n\n  event AccountTransactionExecuted(\n    address account,\n    address to,\n    uint256 value,\n    bytes data,\n    bytes response\n  );\n\n  event AccountCallRefunded(\n    address account,\n    address beneficiary,\n    address token,\n    uint256 value\n  );\n\n  /**\n   * @dev public constructor\n   */\n  constructor() public Initializable() {}\n\n  // external functions\n\n  function initialize(\n    address gateway_\n  )\n    external\n    onlyInitializer\n  {\n    // GatewayRecipient\n    _initializeGatewayRecipient(gateway_);\n  }\n\n  function addAccountOwner(\n    address account,\n    address owner\n  )\n    external\n  {\n    _verifySender(account);\n\n    require(\n      owner != address(0)\n    );\n\n    require(\n      !accounts[account].owners[owner].verifyAtCurrentBlock()\n    );\n\n    accounts[account].owners[owner].added = true;\n    accounts[account].owners[owner].removedAtBlockNumber = 0;\n\n    emit AccountOwnerAdded(\n      account,\n      owner\n    );\n  }\n\n  function removeAccountOwner(\n    address account,\n    address owner\n  )\n    external\n  {\n    address sender = _verifySender(account);\n\n    require(\n      owner != sender\n    );\n\n    require(\n      accounts[account].owners[owner].verifyAtCurrentBlock()\n    );\n\n    accounts[account].owners[owner].removedAtBlockNumber = block.number;\n\n    emit AccountOwnerRemoved(\n      account,\n      owner\n    );\n  }\n\n  function executeAccountTransaction(\n    address account,\n    address to,\n    uint256 value,\n    bytes calldata data\n  )\n    external\n  {\n    _verifySender(account);\n\n    _deployAccount(account);\n\n    bytes memory response = _executeAccountTransaction(\n      account,\n      to,\n      value,\n      data\n    );\n\n    emit AccountTransactionExecuted(\n      account,\n      to,\n      value,\n      data,\n      response\n    );\n  }\n\n  function refundAccountCall(\n    address account,\n    address token,\n    uint256 value\n  )\n    external\n  {\n    _verifySender(account);\n\n    _deployAccount(account);\n\n    /* solhint-disable avoid-tx-origin */\n    if (token == address(0)) {\n      _executeAccountTransaction(\n        account,\n        tx.origin,\n        value,\n        new bytes(0)\n      );\n    } else {\n      bytes memory response = _executeAccountTransaction(\n        account,\n        token,\n        0,\n        abi.encodeWithSelector(\n          ERC20Token(token).transfer.selector,\n          tx.origin,\n          value\n        )\n      );\n\n      if (response.length > 0) {\n        require(\n          abi.decode(response, (bool))\n        );\n      }\n    }\n\n    emit AccountCallRefunded(\n      account,\n      tx.origin,\n      token,\n      value\n    );\n\n    /* solhint-enable avoid-tx-origin */\n  }\n\n  // external functions (views)\n\n  function computeAccountAddress(\n    address saltOwner\n  )\n    external\n    view\n    returns (address)\n  {\n    return _computeAccountAddress(saltOwner);\n  }\n\n  function isAccountDeployed(\n    address account\n  )\n    external\n    view\n    returns (bool)\n  {\n    return accounts[account].deployed;\n  }\n\n  function verifyAccountOwner(\n    address account,\n    address owner\n  )\n    external\n    view\n    returns (bool)\n  {\n    return _verifyAccountOwner(account, owner);\n  }\n\n  function verifyAccountOwnerAtBlock(\n    address account,\n    address owner,\n    uint256 blockNumber\n  )\n    external\n    view\n    returns (bool)\n  {\n    bool result = false;\n\n    if (_verifyAccountOwner(account, owner)) {\n      result = true;\n    } else {\n      result = accounts[account].owners[owner].verifyAtBlock(blockNumber);\n    }\n\n    return result;\n  }\n\n  // private functions\n\n  function _verifySender(\n    address account\n  )\n    private\n    returns (address)\n  {\n    address sender = _getContextSender();\n\n    if (accounts[account].owners[sender].added) {\n      require(\n        accounts[account].owners[sender].removedAtBlockNumber == 0\n      );\n    } else {\n      require(\n        accounts[account].salt == 0\n      );\n\n      bytes32 salt = keccak256(\n        abi.encodePacked(sender)\n      );\n\n      require(\n        account == _computeAccountAddress(salt)\n      );\n\n      accounts[account].salt = salt;\n      accounts[account].owners[sender].added = true;\n\n      emit AccountOwnerAdded(\n        account,\n        sender\n      );\n    }\n\n    return sender;\n  }\n\n  function _deployAccount(\n    address account\n  )\n    internal\n  {\n    if (!accounts[account].deployed) {\n      _deployAccount(\n        accounts[account].salt\n      );\n\n      accounts[account].deployed = true;\n\n      emit AccountDeployed(\n        account\n      );\n    }\n  }\n\n  // private functions (views)\n\n  function _computeAccountAddress(\n    address saltOwner\n  )\n    private\n    view\n    returns (address)\n  {\n    bytes32 salt = keccak256(\n      abi.encodePacked(saltOwner)\n    );\n\n    return _computeAccountAddress(salt);\n  }\n\n  function _verifyAccountOwner(\n    address account,\n    address owner\n  )\n    private\n    view\n    returns (bool)\n  {\n    bool result;\n\n    if (accounts[account].owners[owner].added) {\n      result = accounts[account].owners[owner].removedAtBlockNumber == 0;\n    } else if (accounts[account].salt == 0) {\n      result = account == _computeAccountAddress(owner);\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/gateway/GatewayRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../common/libs/BytesLib.sol\";\n\n\n/**\n * @title GatewayRecipient\n */\ncontract GatewayRecipient {\n  using BytesLib for bytes;\n\n  address public gateway;\n\n  /**\n   * @dev internal constructor\n   */\n  constructor() internal {}\n\n  // internal functions\n\n  function _initializeGatewayRecipient(\n    address gateway_\n  )\n    internal\n  {\n    gateway = gateway_;\n  }\n\n  // internal functions (views)\n\n  function _getContextAccount()\n    internal\n    view\n    returns (address)\n  {\n    return _getContextAddress(40);\n  }\n\n  function _getContextSender()\n    internal\n    view\n    returns (address)\n  {\n    return _getContextAddress(20);\n  }\n\n  function _getContextData()\n    internal\n    view\n    returns (bytes calldata)\n  {\n    bytes calldata result;\n\n    if (_isGatewaySender()) {\n      result = msg.data[:msg.data.length - 40];\n    } else {\n      result = msg.data;\n    }\n\n    return result;\n  }\n\n  // private functions (views)\n\n  function _getContextAddress(\n    uint256 offset\n  )\n    private\n    view\n    returns (address)\n  {\n    address result = address(0);\n\n    if (_isGatewaySender()) {\n      uint from = msg.data.length - offset;\n      result = bytes(msg.data[from:from + 20]).toAddress();\n    } else {\n      result = msg.sender;\n    }\n\n    return result;\n  }\n\n  function _isGatewaySender()\n    private\n    view\n    returns (bool)\n  {\n    bool result;\n\n    if (msg.sender == gateway) {\n      require(\n        msg.data.length >= 44\n      );\n\n      result = true;\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/common/account/Account.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../access/Controlled.sol\";\n\n\n/**\n * @title Account\n */\ncontract Account is Controlled {\n  /**\n   * @dev public constructor\n   */\n  constructor() public payable Controlled() {}\n\n  /**\n   * @dev receive\n   */\n  receive()\n    external\n    payable\n  {\n    //\n  }\n\n  // external functions\n\n  function executeTransaction(\n    address to,\n    uint256 value,\n    bytes calldata data\n  )\n    external\n    onlyController\n    returns (bytes memory)\n  {\n    bytes memory result;\n    bool succeeded;\n\n    // solhint-disable-next-line avoid-call-value, avoid-low-level-calls\n    (succeeded, result) = payable(to).call{value: value}(data);\n\n    require(\n      succeeded\n    );\n\n    return result;\n  }\n}\n"
    },
    "src/common/access/Controlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @title Controlled\n */\ncontract Controlled {\n  address public controller;\n\n  // modifiers\n\n  modifier onlyController() {\n    require(\n      msg.sender == controller\n    );\n\n    _;\n  }\n\n  /**\n   * @dev internal constructor\n   */\n  constructor()\n    internal\n  {\n    controller = msg.sender;\n  }\n}\n"
    },
    "src/common/libs/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @title BytesLib\n */\nlibrary BytesLib {\n  function toAddress(\n    bytes memory data\n  )\n    internal\n    pure\n    returns (address)\n  {\n    address result;\n\n    require(\n      data.length == 20\n    );\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      result := div(mload(add(data, 0x20)), 0x1000000000000000000000000)\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/gateway/GatewayRecipientMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./GatewayRecipient.sol\";\n\n\n/**\n * @title GatewayRecipientMock\n */\ncontract GatewayRecipientMock is GatewayRecipient {\n  // events\n\n  event Context(\n    address account,\n    address sender,\n    bytes data\n  );\n\n  /**\n   * @dev public constructor\n   */\n  constructor(address gateway_) public {\n    _initializeGatewayRecipient(gateway_);\n  }\n\n  function emitContext()\n    external\n  {\n    emit Context(\n      _getContextAccount(),\n      _getContextSender(),\n      _getContextData()\n    );\n  }\n}\n"
    },
    "src/utils/BalanceChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../common/token/ERC20Token.sol\";\nimport \"../common/libs/SafeMathLib.sol\";\n\n\n/**\n * @title BalanceChecker\n */\ncontract BalanceChecker {\n  using SafeMathLib for uint256;\n\n  /**\n   * Check the token balances of a wallet for multiple tokens.\n   * Pass 0x0 as a \"token\" address to get ETH balance.\n   *\n   * Possible error throws:\n   *   - extremely large arrays for account and or tokens (gas cost too high)\n   *\n   * Returns a one-dimensional that's user.length * tokens.length long. The\n   * array is ordered by all of the 0th users token balances, then the 1th\n   * user, and so on.\n   */\n  function getBalances(\n    address[] calldata accounts,\n    address[] calldata tokens\n  )\n    external\n    view\n    returns (uint[] memory)\n  {\n    uint[] memory result = new uint[](accounts.length.mul(tokens.length));\n\n    for (uint i = 0; i < accounts.length; i++) {\n      for (uint j = 0; j < tokens.length; j++) {\n        uint index = j.add(tokens.length.mul(i));\n\n        if (tokens[j] != address(0x0)) {\n          result[index] = _getBalance(accounts[i], tokens[j]);\n        } else {\n          result[index] = accounts[i].balance;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function _getBalance(\n    address account,\n    address token\n  )\n    private\n    view\n    returns (uint256)\n  {\n    uint256 result = 0;\n    uint256 tokenCode;\n\n    // check if token is actually a contract\n    // solhint-disable-next-line no-inline-assembly\n    assembly { tokenCode := extcodesize(token) } // contract code size\n\n    if (tokenCode > 0) {\n      // is it a contract and does it implement balanceOf\n      // solhint-disable-next-line avoid-low-level-calls\n      (bool methodExists,) = token.staticcall(abi.encodeWithSelector(\n        ERC20Token(token).balanceOf.selector,\n        account\n      ));\n\n      if (methodExists) {\n        result = ERC20Token(token).balanceOf(account);\n      }\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/gateway/Gateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../account/AccountOwnerRegistry.sol\";\nimport \"../common/libs/SafeMathLib.sol\";\nimport \"../common/libs/SignatureLib.sol\";\nimport \"../common/lifecycle/Initializable.sol\";\nimport \"../common/typedData/TypedDataContainer.sol\";\nimport \"../personal/PersonalAccountRegistry.sol\";\n\n/**\n * @title Gateway\n */\ncontract Gateway is Initializable, TypedDataContainer {\n  using SafeMathLib for uint256;\n  using SignatureLib for bytes32;\n\n  struct DelegatedBatch {\n    uint256 nonce;\n    address[] to;\n    bytes[] data;\n  }\n\n  struct DelegatedBatchWithGasPrice {\n    uint256 nonce;\n    address[] to;\n    bytes[] data;\n    uint256 gasPrice;\n  }\n\n  bytes32 private constant DELEGATED_BATCH_TYPE_HASH = keccak256(\n    \"DelegatedBatch(uint256 nonce,address[] to,bytes[] data)\"\n  );\n\n  bytes32 private constant DELEGATED_BATCH_TYPE_HASH_WITH_GAS_PRICE = keccak256(\n    \"DelegatedBatchWithGasPrice(uint256 nonce,address[] to,bytes[] data,uint256 gasPrice)\"\n  );\n\n  AccountOwnerRegistry public accountOwnerRegistry;\n  PersonalAccountRegistry public personalAccountRegistry;\n\n  mapping(address => uint256) private accountNonce;\n\n  // events\n\n  event BatchDelegated(\n    address sender,\n    bytes batch,\n    bool succeeded\n  );\n\n  /**\n   * @dev public constructor\n   */\n  constructor() public Initializable() {}\n\n  // external functions\n\n  function initialize(\n    AccountOwnerRegistry accountOwnerRegistry_,\n    PersonalAccountRegistry personalAccountRegistry_,\n    bytes32 typedDataDomainNameHash,\n    bytes32 typedDataDomainVersionHash,\n    bytes32 typedDataDomainSalt\n  )\n    external\n    onlyInitializer\n  {\n    accountOwnerRegistry = accountOwnerRegistry_;\n    personalAccountRegistry = personalAccountRegistry_;\n\n    // TypedDataContainer\n    _initializeTypedDataContainer(\n      typedDataDomainNameHash,\n      typedDataDomainVersionHash,\n      typedDataDomainSalt\n    );\n  }\n\n  // public functions\n\n  function sendBatch(\n    address[] memory to,\n    bytes[] memory data\n  )\n    public\n  {\n    _sendBatch(\n      msg.sender,\n      msg.sender,\n      to,\n      data\n    );\n  }\n\n  function sendBatchFromAccount(\n    address account,\n    address[] memory to,\n    bytes[] memory data\n  )\n    public\n  {\n    _sendBatch(\n      account,\n      msg.sender,\n      to,\n      data\n    );\n  }\n\n  function delegateBatch(\n    address account,\n    uint256 nonce,\n    address[] memory to,\n    bytes[] memory data,\n    bytes memory senderSignature\n  )\n    public\n  {\n    require(\n      nonce > accountNonce[account]\n    );\n\n    address sender = _hashPrimaryTypedData(\n      _hashTypedData(\n        nonce,\n        to,\n        data\n      )\n    ).recoverAddress(senderSignature);\n\n    accountNonce[account] = nonce;\n\n    _sendBatch(\n      account,\n      sender,\n      to,\n      data\n    );\n  }\n\n  function delegateBatchWithGasPrice(\n    address account,\n    uint256 nonce,\n    address[] memory to,\n    bytes[] memory data,\n    bytes memory senderSignature\n  )\n    public\n  {\n    require(\n      nonce > accountNonce[account]\n    );\n\n    address sender = _hashPrimaryTypedData(\n      _hashTypedData(\n        nonce,\n        to,\n        data,\n        tx.gasprice\n      )\n    ).recoverAddress(senderSignature);\n\n    accountNonce[account] = nonce;\n\n    _sendBatch(\n      account,\n      sender,\n      to,\n      data\n    );\n  }\n\n  function delegateBatches(\n    bytes[] memory batches,\n    bool revertOnFailure\n  )\n    public\n  {\n    require(\n      batches.length > 0\n    );\n\n    for (uint256 i = 0; i < batches.length; i++) {\n      // solhint-disable-next-line avoid-low-level-calls\n      (bool succeeded,) = address(this).call(batches[i]);\n\n      if (revertOnFailure) {\n        require(\n          succeeded\n        );\n      }\n\n      emit BatchDelegated(\n        msg.sender,\n        batches[i],\n        succeeded\n      );\n    }\n  }\n\n  // public functions (views)\n\n  function hashDelegatedBatch(\n    DelegatedBatch memory delegatedBatch\n  )\n    public\n    view\n    returns (bytes32)\n  {\n    return _hashPrimaryTypedData(\n      _hashTypedData(\n        delegatedBatch.nonce,\n        delegatedBatch.to,\n        delegatedBatch.data\n      )\n    );\n  }\n\n  function hashDelegatedBatchWithGasPrice(\n    DelegatedBatchWithGasPrice memory delegatedBatch\n  )\n    public\n    view\n    returns (bytes32)\n  {\n    return _hashPrimaryTypedData(\n      _hashTypedData(\n        delegatedBatch.nonce,\n        delegatedBatch.to,\n        delegatedBatch.data,\n        delegatedBatch.gasPrice\n      )\n    );\n  }\n\n  // external functions (views)\n\n  function getAccountNonce(\n    address account\n  )\n    external\n    view\n    returns (uint256)\n  {\n    return accountNonce[account];\n  }\n\n  // private functions\n\n  function _sendBatch(\n    address account,\n    address sender,\n    address[] memory to,\n    bytes[] memory data\n  )\n    private\n  {\n    require(\n      account != address(0)\n    );\n\n    require(\n      to.length > 0\n    );\n    require(\n      data.length == to.length\n    );\n\n    if (account != sender) {\n      require(\n        personalAccountRegistry.verifyAccountOwner(account, sender) ||\n        accountOwnerRegistry.verifyAccountOwner(account, sender)\n      );\n    }\n\n    bool succeeded;\n\n    for (uint256 i = 0; i < data.length; i++) {\n      require(\n        to[i] != address(0)\n      );\n\n      // solhint-disable-next-line avoid-low-level-calls\n      (succeeded,) = to[i].call(abi.encodePacked(data[i], account, sender));\n\n      require(\n        succeeded\n      );\n    }\n  }\n\n  // private functions (pure)\n\n  function _hashTypedData(\n    uint256 nonce,\n    address[] memory to,\n    bytes[] memory data\n  )\n    private\n    pure\n    returns (bytes32)\n  {\n    bytes32[] memory dataHashes = new bytes32[](data.length);\n\n    for (uint256 i = 0; i < data.length; i++) {\n      dataHashes[i] = keccak256(data[i]);\n    }\n\n    return keccak256(abi.encode(\n      DELEGATED_BATCH_TYPE_HASH,\n      nonce,\n      keccak256(abi.encodePacked(to)),\n      keccak256(abi.encodePacked(dataHashes))\n    ));\n  }\n\n  function _hashTypedData(\n    uint256 nonce,\n    address[] memory to,\n    bytes[] memory data,\n    uint256 gasPrice\n  )\n    private\n    pure\n    returns (bytes32)\n  {\n    bytes32[] memory dataHashes = new bytes32[](data.length);\n\n    for (uint256 i = 0; i < data.length; i++) {\n      dataHashes[i] = keccak256(data[i]);\n    }\n\n    return keccak256(abi.encode(\n        DELEGATED_BATCH_TYPE_HASH_WITH_GAS_PRICE,\n        nonce,\n        keccak256(abi.encodePacked(to)),\n        keccak256(abi.encodePacked(dataHashes)),\n        gasPrice\n      ));\n  }\n}\n"
    },
    "src/ens/ENSController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../common/access/Guarded.sol\";\nimport \"../common/lifecycle/Initializable.sol\";\nimport \"../common/typedData/TypedDataContainer.sol\";\nimport \"../gateway/GatewayRecipient.sol\";\nimport \"./ENSRegistry.sol\";\n\n/**\n * @title ENSController\n */\ncontract ENSController is Guarded, Initializable, TypedDataContainer, GatewayRecipient {\n  struct Node {\n    address addr;\n  }\n\n  struct SubNodeRegistration {\n    address account;\n    bytes32 node;\n    bytes32 label;\n  }\n\n  bytes32 private constant SUB_NODE_REGISTRATION_TYPE_HASH = keccak256(\n    \"SubNodeRegistration(address account,bytes32 node,bytes32 label)\"\n  );\n\n  bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\n  bytes4 private constant INTERFACE_ADDR_ID = 0x3b3b57de;\n\n  ENSRegistry public registry;\n\n  mapping(bytes32 => Node) private nodes;\n\n  // events\n\n  event AddrChanged(\n    bytes32 indexed node,\n    address addr\n  );\n\n  event NodeAdded(\n    bytes32 node\n  );\n\n  event RegistryChanged(\n    address registry\n  );\n\n  /**\n   * @dev public constructor\n   */\n  constructor() public Guarded() Initializable() {}\n\n  // external functions\n\n  function initialize(\n    ENSRegistry registry_,\n    address[] calldata guardians_,\n    address gateway_,\n    bytes32 typedDataDomainNameHash,\n    bytes32 typedDataDomainVersionHash,\n    bytes32 typedDataDomainSalt\n  )\n    external\n    onlyInitializer\n  {\n    require(\n      address(registry_) != address(0)\n    );\n\n    registry = registry_;\n\n    // Guarded\n    _initializeGuarded(guardians_);\n\n    // GatewayRecipient\n    _initializeGatewayRecipient(gateway_);\n\n    // TypedDataContainer\n    _initializeTypedDataContainer(\n      typedDataDomainNameHash,\n      typedDataDomainVersionHash,\n      typedDataDomainSalt\n    );\n  }\n\n  function setRegistry(\n    ENSRegistry registry_\n  )\n    external\n    onlyGuardian\n  {\n    require(\n      address(registry_) != address(0)\n    );\n\n    require(\n      registry_ != registry\n    );\n\n    registry = registry_;\n\n    emit RegistryChanged(\n      address(registry)\n    );\n  }\n\n  function addNode(\n    bytes32 node\n  )\n    external\n  {\n    require(\n      nodes[node].addr == address(0)\n    );\n\n    require(\n      registry.owner(node) == address(this)\n    );\n\n    nodes[node].addr = address(this);\n\n    emit NodeAdded(node);\n  }\n\n  function setAddr(\n    bytes32 node,\n    address addr\n  )\n    external\n  {\n    require(\n      nodes[node].addr == _getContextAccount()\n    );\n\n    nodes[node].addr = addr;\n\n    emit AddrChanged(node, addr);\n  }\n\n  function registerSubNode(\n    bytes32 node,\n    bytes32 label,\n    bytes calldata guardianSignature\n  )\n    external\n  {\n    address account = _getContextAccount();\n\n    bytes32 messageHash = _hashPrimaryTypedData(\n      _hashTypedData(\n        account,\n        node,\n        label\n      )\n    );\n\n    require(\n      _verifyGuardianSignature(messageHash, guardianSignature)\n    );\n\n    bytes32 subNode = keccak256(\n      abi.encodePacked(\n        node,\n        label\n      )\n    );\n\n    require(\n      nodes[node].addr == address(this)\n    );\n\n    require(\n      nodes[subNode].addr == address(0)\n    );\n\n    nodes[subNode].addr = account;\n\n    registry.setSubnodeOwner(node, label, address(this));\n    registry.setResolver(subNode, address(this));\n    registry.setOwner(subNode, account);\n\n    emit AddrChanged(subNode, account);\n  }\n\n  // external functions (views)\n\n  function addr(\n    bytes32 node\n  )\n    external\n    view\n    returns (address)\n  {\n    return nodes[node].addr;\n  }\n\n  // external functions (pure)\n\n  function supportsInterface(\n    bytes4 interfaceID\n  )\n    external\n    pure\n    returns (bool)\n  {\n    return (\n      interfaceID == INTERFACE_META_ID ||\n      interfaceID == INTERFACE_ADDR_ID\n    );\n  }\n\n  // public functions (views)\n\n  function hashSubNodeRegistration(\n    SubNodeRegistration memory subNodeRegistration\n  )\n    public\n    view\n    returns (bytes32)\n  {\n    return _hashPrimaryTypedData(\n      _hashTypedData(\n        subNodeRegistration.account,\n        subNodeRegistration.node,\n        subNodeRegistration.label\n      )\n    );\n  }\n\n  // private functions (pure)\n\n  function _hashTypedData(\n    address account,\n    bytes32 node,\n    bytes32 label\n  )\n    private\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encode(\n      SUB_NODE_REGISTRATION_TYPE_HASH,\n      account,\n      node,\n      label\n    ));\n  }\n}\n"
    },
    "src/ens/ENSRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @title ENSRegistry\n */\ncontract ENSRegistry {\n  struct Record {\n    address owner;\n    address resolver;\n    uint64 ttl;\n  }\n\n  mapping(bytes32 => Record) private records;\n\n  // events\n\n  event NewOwner(\n    bytes32 indexed node,\n    bytes32 indexed label,\n    address owner\n  );\n\n  event Transfer(\n    bytes32 indexed node,\n    address owner\n  );\n\n  event NewResolver(\n    bytes32 indexed node,\n    address resolver\n  );\n\n  event NewTTL(\n    bytes32 indexed node,\n    uint64 ttl\n  );\n\n  // modifiers\n\n  modifier onlyNodeOwner(\n    bytes32 node\n  ) {\n    require(\n      records[node].owner == msg.sender\n    );\n\n    _;\n  }\n\n  /**\n   * @dev public constructor\n   */\n  constructor()\n    public\n  {\n    records[0x0].owner = msg.sender;\n  }\n\n  // external functions\n\n  function setOwner(\n    bytes32 node,\n    address owner\n  )\n    external\n    onlyNodeOwner(node)\n  {\n    records[node].owner = owner;\n\n    emit Transfer(node, owner);\n  }\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner\n  )\n    external\n    onlyNodeOwner(node)\n  {\n    bytes32 subNode = keccak256(\n      abi.encodePacked(\n        node,\n        label\n      )\n    );\n\n    records[subNode].owner = owner;\n\n    emit NewOwner(node, label, owner);\n  }\n\n  function setResolver(\n    bytes32 node,\n    address resolver\n  )\n    external\n    onlyNodeOwner(node)\n  {\n    records[node].resolver = resolver;\n\n    emit NewResolver(node, resolver);\n  }\n\n  function setTTL(\n    bytes32 node,\n    uint64 ttl\n  )\n    external\n    onlyNodeOwner(node)\n  {\n    records[node].ttl = ttl;\n\n    emit NewTTL(node, ttl);\n  }\n\n  // external functions (views)\n\n  function owner(\n    bytes32 node\n  )\n    external\n    view\n    returns (address)\n  {\n    return records[node].owner;\n  }\n\n  function resolver(\n    bytes32 node\n  )\n    external\n    view\n    returns (address)\n  {\n    return records[node].resolver;\n  }\n\n  function ttl(\n    bytes32 node\n  )\n    external\n    view\n    returns (uint64)\n  {\n    return records[node].ttl;\n  }\n}\n"
    },
    "src/tokens/WrappedWeiToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../common/lifecycle/Initializable.sol\";\nimport \"../common/token/ERC20Token.sol\";\n\n/**\n * @title WrappedWeiToken\n */\ncontract WrappedWeiToken is Initializable, ERC20Token {\n  mapping(address => bool) private consumers;\n\n  // events\n\n  event ConsumerAdded(\n    address consumer\n  );\n\n  event ConsumerRemoved(\n    address consumer\n  );\n\n  /**\n   * @dev public constructor\n   */\n  constructor()\n    public\n    payable\n    Initializable()\n  {\n    name = \"Wrapped Wei\";\n    symbol = \"WWEI\";\n\n    if (msg.value > 0) {\n      _mint(msg.sender, msg.value);\n    }\n  }\n\n  /**\n   * @dev receive\n   */\n  receive()\n    external\n    payable\n  {\n    _mint(msg.sender, msg.value);\n  }\n\n  // external functions\n\n  function initialize(\n    address[] calldata consumers_\n  )\n    external\n    onlyInitializer\n  {\n    if (consumers_.length == 0) {\n      consumers[msg.sender] = true;\n    } else {\n      uint consumersLen = consumers_.length;\n      for (uint i = 0; i < consumersLen; i++) {\n        _addConsumer(consumers_[i]);\n      }\n    }\n  }\n\n  function startConsuming()\n    external\n  {\n    _addConsumer(msg.sender);\n  }\n\n  function stopConsuming()\n    external\n  {\n    require(\n      consumers[msg.sender]\n    );\n\n    consumers[msg.sender] = false;\n\n    emit ConsumerRemoved(msg.sender);\n  }\n\n  function depositTo(\n    address to\n  )\n    external\n    payable\n  {\n    _mint(to, msg.value);\n  }\n\n  function withdraw(\n    uint256 value\n  )\n    external\n  {\n    _withdraw(msg.sender, msg.sender, value);\n  }\n\n  function withdrawTo(\n    address to,\n    uint256 value\n  )\n    external\n  {\n    _withdraw(msg.sender, to, value);\n  }\n\n  function withdrawAll()\n    external\n  {\n    _withdraw(msg.sender, msg.sender, balances[msg.sender]);\n  }\n\n  function withdrawAllTo(\n    address to\n  )\n    external\n  {\n    _withdraw(msg.sender, to, balances[msg.sender]);\n  }\n\n  // external functions (views)\n\n  function isConsumer(\n    address consumer\n  )\n    external\n    view\n    returns (bool)\n  {\n    return consumers[consumer];\n  }\n\n  // internal functions\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 value\n  )\n    override\n    internal\n  {\n    if (consumers[to]) {\n      _withdraw(from, to, value);\n    } else {\n      super._transfer(from, to, value);\n    }\n  }\n\n  // private functions\n\n  function _addConsumer(\n    address consumer\n  )\n    private\n  {\n    require(\n      !consumers[consumer]\n    );\n\n    consumers[consumer] = true;\n\n    emit ConsumerAdded(consumer);\n  }\n\n  function _withdraw(\n    address from,\n    address to,\n    uint256 value\n  )\n    private\n  {\n    _burn(from, value);\n\n    require(\n      // solhint-disable-next-line check-send-result\n      payable(to).send(value)\n    );\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}